【独習C＃ 第5版】
-----------------------------------------------------------------------------------------
 Chapter01 イントロダクション
-----------------------------------------------------------------------------------------
------------------------------------------------------------
 1.1 C#の特徴
------------------------------------------------------------
・マルチパラダイム言語
・CIL（共通中間言語）

・.NET Framework
・.NET Core（v5.0以降は.NET)
・Xamarin（Mono）

・共通言語ランタイム（CLR：Common Language Runtime）
・基本ライブラリ

------------------------------------------------------------
 1.2 C#アプリを開発／実行するための基本環境
------------------------------------------------------------

------------------------------------------------------------
 1.3 C#プログラミングの基本
------------------------------------------------------------


-----------------------------------------------------------------------------------------
 Chapter02 C#の基本
-----------------------------------------------------------------------------------------
------------------------------------------------------------
 2.1 変数
------------------------------------------------------------
・逐語的識別子... 先頭に「@」を付けることで、例外的に予約語を識別子にすることもできる。（例）@if

------------------------------------------------------------
 2.2 データ型
------------------------------------------------------------
・スタック... 値型の実際の値、参照型のアドレス値を格納するメモリ領域
・ヒープ...   参照型の実際の値を格納するメモリ領域

------------------------------------------------------------
 2.3 リテラル
------------------------------------------------------------
■逐語的文字列リテラル
  例）
    Console.WriteLine(@"C:\Windows\AppPatch\en-US");
    Console.WriteLine(@"あいうえお
    かきくけこ
    さしすせそ");

■文字列への変数展開 [6.0]
  例）
    Console.WriteLine($"こんにちは、{name}さん！");

■組み合わせ
  例）
    Console.WriteLine($@"おはよう、{name}さん！
    こんにちは、{name}さん！
    さようなら、{name}さん！");

------------------------------------------------------------
 2.4 型変数
------------------------------------------------------------
■文字列⇒数値の変換
  int...   Int32.Parse("108");
  float... Single.Parse("0.113");

■数値⇒文字列の変換
  num.ToString();

------------------------------------------------------------
 2.5 参照型
------------------------------------------------------------
■参照型
  ・クラス型（組み込み型のstring、objectを含む）
  ・インターフェイス型
  ・デリゲート型
  ・配列型

■クラス
   └ メンバー
        ├ フィールド
        └ メソッド

├─
└─


■new式での型省略 [9.0]
  例）
    ・フィールドでの型省略
        public SortedDictionary<string, FileInfo> Map = new ();

    ・メソッド呼出での型省略
        var dt = new DateTime(2022, 02, 15, 13, 17, 23);
        dt.Add( new (3, 15, 30, 0) );

■null条件演算子... オブジェクトが非nullのときだけ、そのメンバーにアクセスしたい（＝nullの場合はそのままnullを返したい）
  例）
    string str = null;
    string unspace = str?.Trim();	← strがnullでもエラーにならない

    ※プロパティ、インデクサーでも利用可能。
    obj?.Leng	（プロパティ）
    obj?[0]		（インデクサー）

■null許容型（Nullable型）
  例）
    int? num1 = 108;	// 〇
    int? num2 = null;	// 〇... int?型：nullを表現できる（無効な値であることが明らか）
    int  num3 = null;	// ×

    以下はいずれも意味的には等価
    int? num;
    Nullable<int> num;

■null許容型の変換
  例）
    int i = 108;
    int? num = i;		// 〇（暗黙的変換）

    int? num = 108;
    int i = (int)num;	// 〇（明示的なキャストが必要）

    int? num = null;
    int i = (int)num;	// ×（エラー）

■null許容型のメンバー
  例）
    // 変数numが値を持っていれば、その値を取得
    if( num.HasValue )
    {
    	int i = num.Value;
    }

■null許容参照型 [8.0]
・#nullableディレクティブ
  例）
   #nullable enable
     Null許容を有効化（＝null禁止）
   
   #nullable disable
     Null許容を無効化

■null免除演算子 [8.0]
  例）
    string?[] format = { "2022-12-25 10:16:23" };
    var dt = DateTime.Parse( format[0] );		← 警告（nullである可能性がある）

    【従来】
    if( format[0] is { } item)	← nullチェック
    {
    	var dt = DateTime.Parse(item);
    }

    【null免除演算子】
    var dt = DateTime.Parse( format[0]! );		※nullでないことの責任は開発者に委ねられる点に注意。

■配列の宣言
  ① int[] data = new int[5];				← 配列のサイズだけを宣言
  ② int[] data = { 1, 2, 3, 4, 5 };		← 初期値を指定した宣言
     int[] data = {
     		"あいうえお",
     		"かきくけこ",
     		"さしすせそ",
     };
     FileInfo files = {
     		new FileInfo(@"C:\dataSelfCsharp\Chap02\.Constcs"),
     		new FileInfo(@"C:\dataSelfCsharp\Chap02\Parse.cs"),
     		new FileInfo(@"C:\dataSelfCsharp\Chap02\ToString.cs"),
     );
  ③ int[] data;
     data = new[] { 1, 2, 3, 4, 5 };		← 宣言と初期化を別の文とした場合、初期値の前に「new[]」を付与しなければならない。
  ④ var data = new[] { 1, 2, 3, 4, 5 };	← varによる宣言（varを利用した場合には、「new[]」を省略できない）

■配列の特殊なインデックス／範囲指定 [8.0]
・ｍ..n： m ～ n番目の要素（n番目は含まない）
・^m   ： 後方から m番目の要素
  例）
    var list = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    string.Join(" ", list[1..3]  );		// 結果：2 3
    string.Join(" ", list[..2]   );		// 結果：1 2
    string.Join(" ", list[2..]   );		// 結果：3 4 5 6 7 8 9
    string.Join(" ", list[^2]    );		// 結果：8
    string.Join(" ", list[1..^1] );		// 結果：2 3 4 5 6 7 8
    string.Join(" ", list[1..1]  );		// 結果：空

■多次元配列
・2次元配列
    int[,] data = new[3, 3];

  宣言＋初期化
    int[,] data = {
        { 10, 11, 12 },
        { 20, 21, 22 },
    };

    var data = new[,] {
        { 10, 11, 12 },
        { 20, 21, 22 },
    };

  値の取り出し
    data[0,1];		// 結果：11


・３次元配列
    int[,,] data = new[3, 3, 3];

■ジャグ配列
　※※※ 一旦省略 ※※※


-----------------------------------------------------------------------------------------
 Chapter03 演算子
-----------------------------------------------------------------------------------------
・演算子（オペレーター）
・非演算子（オペランド）

------------------------------------------------------------
 3.1 算術演算子
------------------------------------------------------------

------------------------------------------------------------
 3.2 代入演算子
------------------------------------------------------------

---------------------------------------------------
 3.3 関係演算子（比較演算子）
---------------------------------------------------
-------------------------------------
 3.3.1 同一性と同値性
-------------------------------------
「参照型」において、
  ・同一性... オブジェクト参照同士が同じオブジェクトを参照していること。（同値性を同時に満たしている）
  ・同値性... オブジェクトが同じ値を持っていること。

  ・「==」... オペランドの「同一性」を比較する。
  ・Equalsメソッド... オブジェクトを「同値性」によって比較する。


-------------------------------------
 3.3.3 配列の比較
-------------------------------------
var data1 = new[] { "い", "ろ", "は", };
var data2 = new[] { "い", "ろ", "は", };
　↓
 data1 == data2				// ← false×
 data1.Equals(data2)		// ← false×
★配列の同値性を比較をするには、EnumerableクラスのSequenceEqualメソッドを利用する。
 data1.SequenceEqual(data2)	// ← true〇


-------------------------------------
 3.3.4 条件演算子（?:） 三項演算子
-------------------------------------
■「?:」... 条件演算子（三項演算子）。「条件式 ? 式1 : 式2」がtrueの場合は「式1」、falseの場合は「式2」を返す。
  例）
    var result = (10 > 1) ? "正解" : "不正解";	// ← result="正解"


-------------------------------------
 3.3.5 null合体演算子
-------------------------------------
■「??」... null合体演算子。左辺がnullでなければその値、nullならば右辺の値を返す。
  例）
    var name = null;
    var result = name ?? "名無し";	// ← result="名無し"

    string? str = "山田";
    string def = "権兵衛";
    var result = str ?? def;		// ← result="山田"

■「??=」... null合体演算子。左辺がnullでないならその値を、nullなら右辺の値を代入 [8.0]
  例）
    var name = null;
    name ??= "名無し";	// ← name="名無し"

    var name = "山田";
    name ??= "名無し";	// ← name="山田"


------------------------------------------------------------
 3.4 論理演算子
------------------------------------------------------------
■「^」... 排他的論理和。左右のいずれか一方だけがtrueの場合にtrue。
  例）xはtrue、yはfalseを表すものとする。
    x ^ y	// ← true



-----------------------------------------------------------------------------------------
 Chapter04 制御構文
-----------------------------------------------------------------------------------------
■プログラム構造「順次(順接)」「選択」「反復」
　→これらを組み合わせながらプログラムを組み立てていく手法のことを「構造化プログラミング」

------------------------------------------------------------
 4.1 条件分岐
------------------------------------------------------------
■ド・モルガンの法則
   !A && !B == !(A || B)
   !A || !B == !(A && B)

■空文... 文末のセミコロン「;」だけを示した中身のない文のこと。（意図して空としていることを示す）

■コードメトリックス... コードの保守性／可読性を表すための指標のこと。
  [使い方]
    Visual Studioのメニューから[分析]→[コードメトリックスを計算する]→[ソリューション用]（または[選択したプロジェクト用]）を選択。
    見方は、p.124参照。

-------------------------------------
 4.1.6 switch命令による型判定 [7.0]
-------------------------------------
	switch(obj)
	{
		case int i:
			break;
		case string str:
			break;
		default:
			break;
	}

◆型判定に条件式を加える
	switch(obj)
	{
		case int i when i >= 15:
			break;
		case int i:
			break;
		case string str when str.Length < 10:
			break;
		default:
			break;
	}

■switch式
	var rank = "甲";
	var result = rank switch
		{
			"甲" => "大変良いです。",
			"乙" => "良いです。",
			"丙" => "がんばりましょう。",
			   _ => "???"							// ← default句に相当
			   _ => throw new ArgumentEsception()	// 例外をスローしても良い
		}

	var result = obj switch
		{
			int i when i >= 15 => "15以上の数値です。",
			int i => "数値です。",
			int i when str.Length < 10 => "10文字未満の文字列です。",
			   _ => "意図しない値です。"
		}

------------------------------------------------------------
 4.2 繰り返し処理
------------------------------------------------------------
-------------------------------------
 4.2.3 for命令
-------------------------------------
■for命令による無限ループ
・以下のいずれも無限ループとなる。
	for( i = 1; ; i++ ) { ... }		// 条件式を省略
	for( ; ; ) { ... }				// すべてのセクションを省略

■反復しセクションには複数の文／式も可
  例）
    for( var i = 1; i < 6 ; Console,WriteLine($"{i}番目のループです。"), i++);

    for( int i =1, j = 1; i < 6; i++, j++ ) { ... }


-------------------------------------
 4.3.3 ループのネストとbreak／continue命令
-------------------------------------
■「$"{result, 2}」... 変数resultを最低2桁で表示しなさい、という意味。

------------------------------------------------------------
 4.3 ループ制御
------------------------------------------------------------
------------------------------------------------------------
 4.4 制御命令のその他の話題
------------------------------------------------------------


-----------------------------------------------------------------------------------------
 Chapter05 標準ライブラリ
-----------------------------------------------------------------------------------------
------------------------------------------------------------
 5.1 文字列の操作
------------------------------------------------------------
-------------------------------------
 5.1.3 文字列がnull／空文字であるか判定する
-------------------------------------
■「null or 空文字」の判定
   String.IsNullOrEmpty(str1);

■「null or 空文字 or 空白だけの文字列」の判定 
   String.IsNullOrWhiteSpace(str2);

------------------------------------------------------------
 5.2 正規表現
------------------------------------------------------------

------------------------------------------------------------
 5.3 日付／時刻
------------------------------------------------------------
■現在の日付／時刻から生成
  例）
    DateTime.Now	// 結果：2022/02/25 7:52:48
    DateTime.Today	// 結果：2022/02/25 0:00:00

■日付／時刻の文字列から変換
  例）
    DateTime.Parse("2022/02/15 13:17:23");			// 結果：2022/02/15 13:17:23
    DateTime.Parse("令和4年2月15日 13時17分23秒");	// 結果：2022/02/15 13:17:23

    Datetime dt;
    if ( DateTime.TryParse("2022/02/15 13:17:23", out dt) )
    {
    	Console.WriteLine(dt);
    }

■任意の書式文字列から取得
  ※※※ 一旦省略 ※※※


------------------------------------------------------------
 5.4 ファイルの操作
------------------------------------------------------------

------------------------------------------------------------
 5.5 その他の機能
------------------------------------------------------------



-----------------------------------------------------------------------------------------
 Chapter06 コレクション
-----------------------------------------------------------------------------------------
・System.Collections.Generic名前空間

------------------------------------------------------------
 6.1 コレクションAPIの基本
------------------------------------------------------------
■コレクション初期化子
  例）
    var list = new List<string>() {
    	"あいうえお",
    	"かきくけこ",
    	"さしすせそ",
    };
    ※コンストラクターが引数を取らない場合には「()」は省略可能。
    ※LinkedList、Stack、QueueクラスはAddメソッドを持たないので、コレクション初期化子を利用できない。

■配列⇒コレクションの変換
  例）インスタンス化時に、コンストラクタ―の引数として配列を渡す。
    var array = new[] { "バラ", "ひまわり", "あさがお" };
    var list = new List<string>( array );

■コレクション⇒配列の変換
  例）ToArrayメソッドを利用
    var list = new List<string> { "バラ", "ひまわり", "あさがお" };
    var array = list.ToArray();

■ディクショナリの初期化
・コレクション初期化子
  例）
    var flower = new Dictionary<string, string>() {
    	{ "Rose", "バラ" },
    	{ "Sunflower", "ひまわり" },
    	{ "Morning Flory", "あさがお" },
    }

・インデックス初期化子 [6.0]
  例）
    var flower = new Dictionary<string, string>() {
    	["Rose"] = "バラ" },
    	["Sunflower] = "ひまわり" },
    	["Morning Flory] = "あさがお" },
    }


------------------------------------------------------------
 6.2 リスト（List／LinkedList／Stack／Queue）
------------------------------------------------------------
■ListとLinkedListの使い分け
・LinkedList... 要素の挿入／削除が頻繁に発生する、また、リストに順にアクセスしていくような用途が主となる場合。
・List...       それ以外、要素の取得や既存要素の書き換えが多い場合。


------------------------------------------------------------
 6.3 セット（HashSet／SortedSet）
------------------------------------------------------------


------------------------------------------------------------
 6.4 ディクショナリ（Dictionary／SortedDictionary／SortedList）
------------------------------------------------------------
































